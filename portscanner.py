#!/usr/bin/env python3

# Usage: 
# Single target, single port -->#./portscan.py --target 192.168.1.1 --port 80
# Multiple targets and port range --> #./portscan.py --target 192.168.1.1,192.168.1.10 --port 80-100

import argparse

import sys
import socket
import subprocess

# Colors
G = "\033[92m"  # green
Y = "\033[93m"  # yellow
B = "\033[94m"  # blue
R = "\033[91m"  # red
W = "\033[0m"   # white

TOP_PORTS = [
    "21",    # FTP
    "22",    # SSH
    "23",    # Telnet
    "25",    # SMTP
    "53",    # DNS
    "80",    # HTTP
    "110",   # POP3
    "135",   # MSRPC
    "139",   # NETBIOS
    "143",   # IMAP
    "443",   # HTTPS
    "445",   # SMB
    "465",   # SMTPS
    "587",   # SMTP (Mail submission)
    "993",   # IMAPS
    "995",   # POP3S
    "1433",  # Microsoft SQL Server
    "1521",  # Oracle database default listener
    "3306",  # MySQL database
    "3389",  # Remote Desktop Protocol (RDP)
    "5432",  # PostgreSQL database
    "5900",  # Virtual Network Computing (VNC)
    "8080"   # Alternative HTTP port (commonly used for proxies)
]

script_db = {
    "21": "ftp*",
    "445": "smb-vuln*",
    "3389": "rdp-vuln*"
}

OPEN_PORTS = []
SCRIPTS = []

def parse_args():
    parser = argparse.ArgumentParser(description="Scan Ports for IP addresses")
    parser.add_argument("-t", "--target", metavar="", required=True, help="Host to be targetted for scanning.")
    parser.add_argument("-p", "--port", metavar="", required=True, help="Range of ports to be scanned.")
    return parser.parse_args()


def scan_connect(target, port):
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        socket.setdefaulttimeout(1)
        result = sock.connect_ex((target, port))

        if result == 0:
            print(f"[+] Port {port} is {G}OPEN{W}.")
            OPEN_PORTS.append(str(port))
        else:
            pass
            # print(f"[-] Port {port} is {R}CLOSED{W}.")
        sock.close()

    except KeyboardInterrupt:
        print("\nExiting...")
        sys.exit()

    except socket.error:
        print(f"{R}[!] Could not connect to server.{W}")
        sys.exit()


def scan_port(target, ports):
    print(f"\n{G}[*] Scanning {target}:{W}")
    if "-" in ports:
        t_ports = ports.split("-")
        for port in range(int(t_ports[0]), int(t_ports[1]) + 1):
            scan_connect(target, port)
    elif "," in ports:
        t_ports = ports.split(",")
        for port in t_ports:
            port = int(port)
            scan_connect(target, port)
    else:
        port = int(ports)
        scan_connect(target, port)


def run_nmap_scan(target, open_ports, scripts):
    print(f"\n{G}[*] Running NMAP Scan for {target}{W}")
    open_ports = ",".join(open_ports)
    command = f"nmap -T4 -A -p {open_ports} --script {','.join(scripts)} {target} -oN Dumps/{target}.nmap".split()
    result = subprocess.run(command, capture_output=True, text=True, check=True)

    if result.returncode == 0:
        print(f"\n{G}[*] Nmap scan completed successfully!{W}")
        print(result.stdout)
    else:
        print("Nmap scan failed!")
        print("Error message:")
        print(result.stderr)


def main():
    args = parse_args()
    target = args.target
    ports = args.port

    if ports.upper() == "TOP" or not ports:
        ports = ",".join(TOP_PORTS)
    else:
        print(f"{R}[!] Please specify port(s) to scan or choose 'TOP'.{W}")
        return
    
    if "," in target:
        print(f"{G}[*] Scanning multiple targets...{W}")
        for ip_addr in target.split(","):
            scan_port(ip_addr.strip(" "), ports)
    else:
        scan_port(target, ports)

    if not OPEN_PORTS:
        print(f"{R}[!] No open ports found. {W}")
        return
    else:
        for port in OPEN_PORTS:
            SCRIPTS.append(script_db.get(port, ""))
        run_nmap_scan(target, OPEN_PORTS, list(set(SCRIPTS)))


if __name__ == "__main__": 
    main()